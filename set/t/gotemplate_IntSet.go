// Code generated by gotemplate. DO NOT EDIT.

// Package set is a template Set type
//
// Tries to be similar to Python's set type
package t

// An A is the element of the set
//
// template type Set(A)

// SetNothing is used as a zero sized member in the map
type IntSetNothing struct{}

// Set provides a general purpose set modeled on Python's set type.
type IntSet struct {
	m map[int]IntSetNothing
}

// NewSizedSet returns a new empty set with the given capacity
func NewSizedIntSet(capacity int) *IntSet {
	return &IntSet{
		m: make(map[int]IntSetNothing, capacity),
	}
}

// NewSet returns a new empty set
func NewIntSet() *IntSet {
	return NewSizedIntSet(0)
}

// Len returns the number of elements in the set
func (s *IntSet) Len() int {
	return len(s.m)
}

// Contains returns whether elem is in the set or not
func (s *IntSet) Contains(elem int) bool {
	_, found := s.m[elem]
	return found
}

// Add adds elem to the set, returning the set
//
// If the element already exists then it has no effect
func (s *IntSet) Add(elem int) *IntSet {
	s.m[elem] = IntSetNothing{}
	return s
}

// AddList adds a list of elems to the set
//
// If the elements already exists then it has no effect
func (s *IntSet) AddList(elems []int) *IntSet {
	for _, elem := range elems {
		s.m[elem] = IntSetNothing{}
	}
	return s
}

// Discard removes elem from the set
//
// If it wasn't in the set it does nothing
//
// It returns the set
func (s *IntSet) Discard(elem int) *IntSet {
	delete(s.m, elem)
	return s
}

// Remove removes elem from the set
//
// It returns whether the elem was in the set or not
func (s *IntSet) Remove(elem int) bool {
	_, found := s.m[elem]
	if found {
		delete(s.m, elem)
	}
	return found
}

// Pop removes elem from the set and returns it
//
// It also returns whether the elem was found or not
func (s *IntSet) Pop(elem int) (int, bool) {
	_, found := s.m[elem]
	if found {
		delete(s.m, elem)
	}
	return elem, found
}

// AsList returns all the elements as a slice
func (s *IntSet) AsList() []int {
	elems := make([]int, len(s.m))
	i := 0
	for elem := range s.m {
		elems[i] = elem
		i++
	}
	return elems
}

// Clear removes all the elements
func (s *IntSet) Clear() *IntSet {
	s.m = make(map[int]IntSetNothing)
	return s
}

// Copy returns a shallow copy of the Set
func (s *IntSet) Copy() *IntSet {
	newSet := NewSizedIntSet(len(s.m))
	for elem := range s.m {
		newSet.m[elem] = IntSetNothing{}
	}
	return newSet
}

// Difference returns a new set with all the elements that are in this
// set but not in the other
func (s *IntSet) Difference(other *IntSet) *IntSet {
	newSet := NewSizedIntSet(len(s.m))
	for elem := range s.m {
		if _, found := other.m[elem]; !found {
			newSet.m[elem] = IntSetNothing{}
		}
	}
	return newSet
}

// DifferenceUpdate removes all the elements that are in the other set
// from this set.  It returns the set.
func (s *IntSet) DifferenceUpdate(other *IntSet) *IntSet {
	m := s.m
	for elem := range other.m {
		delete(m, elem)
	}
	return s
}

// Intersection returns a new set with all the elements that are only in this
// set and the other set. It returns the new set.
func (s *IntSet) Intersection(other *IntSet) *IntSet {
	newSet := NewSizedIntSet(len(s.m) + len(other.m))
	for elem := range s.m {
		if _, found := other.m[elem]; found {
			newSet.m[elem] = IntSetNothing{}
		}
	}
	for elem := range other.m {
		if _, found := s.m[elem]; found {
			newSet.m[elem] = IntSetNothing{}
		}
	}
	return newSet
}

// IntersectionUpdate changes this set so that it only contains
// elements that are in both this set and the other set.  It returns
// the set.
func (s *IntSet) IntersectionUpdate(other *IntSet) *IntSet {
	for elem := range s.m {
		if _, found := other.m[elem]; !found {
			delete(s.m, elem)
		}
	}
	return s
}

// Union returns a new set with all the elements that are in either
// set. It returns the new set.
func (s *IntSet) Union(other *IntSet) *IntSet {
	newSet := NewSizedIntSet(len(s.m) + len(other.m))
	for elem := range s.m {
		newSet.m[elem] = IntSetNothing{}
	}
	for elem := range other.m {
		newSet.m[elem] = IntSetNothing{}
	}
	return newSet
}

// Update adds all the elements from the other set to this set.
// It returns the set.
func (s *IntSet) Update(other *IntSet) *IntSet {
	for elem := range other.m {
		s.m[elem] = IntSetNothing{}
	}
	return s
}

// IsSuperset returns a bool indicating whether this set is a superset of other set.
func (s *IntSet) IsSuperset(strict bool, other *IntSet) bool {
	if strict && len(other.m) >= len(s.m) {
		return false
	}

	for v := range other.m {
		if _, found := s.m[v]; found == false {
			return false
		}
	}
	return true
}

// IsSubset returns a bool indicating whether this set is a subset of other set.
func (s *IntSet) IsSubset(strict bool, other *IntSet) bool {
	if strict && len(s.m) >= len(other.m) {
		return false
	}

	for v := range s.m {
		if _, found := other.m[v]; found == false {
			return false
		}
	}
	return true
}

// IsDisjoint returns a bool indicating whether this set and other set have no elements in common.
func (s *IntSet) IsDisjoint(other *IntSet) bool {
	for v := range s.m {
		if other.Contains(v) {
			return false
		}
	}
	return true
}

// SymmetricDifference returns a new set of all elements that are a member of exactly
// one of this set and other set(elements which are in one of the sets, but not in both).
func (s *IntSet) SymmetricDifference(other *IntSet) *IntSet {
	work1 := s.Union(other)
	work2 := s.Intersection(other)
	for v := range work2.m {
		delete(work1.m, v)
	}
	return work1
}

// SymmetricDifferenceUpdate modifies this set to be a set of all elements that are a member
// of exactly one of this set and other set(elements which are in one of the sets,
// but not in both) and returns this set.
func (s *IntSet) SymmetricDifferenceUpdate(other *IntSet) *IntSet {
	work := s.SymmetricDifference(other)
	*s = *work
	return s
}
